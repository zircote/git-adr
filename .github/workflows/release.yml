name: Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 0.1.1)'
        required: true
        type: string

permissions:
  contents: write
  id-token: write

jobs:
  build:
    name: Build Package
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - name: Install uv
        uses: astral-sh/setup-uv@v7
        with:
          enable-cache: true

      - name: Set up Python
        run: uv python install 3.12

      - name: Update version from tag or input
        env:
          REF_NAME: ${{ github.ref_name }}
          INPUT_VERSION: ${{ inputs.version }}
        run: |
          # Use input version for workflow_dispatch, or extract from tag
          if [ -n "$INPUT_VERSION" ]; then
            VERSION="$INPUT_VERSION"
          else
            VERSION="${REF_NAME#v}"
          fi
          echo "Setting version to ${VERSION}"
          sed -i "s/^version = .*/version = \"${VERSION}\"/" pyproject.toml
          sed -i "s/__version__ = .*/__version__ = \"${VERSION}\"/" src/git_adr/__init__.py
          grep "^version" pyproject.toml
          grep "__version__" src/git_adr/__init__.py
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"

      - name: Build package
        run: uv build

      - name: Upload package artifacts
        uses: actions/upload-artifact@v6
        with:
          name: dist
          path: dist/

  build-release-artifacts:
    name: Build Release Artifacts
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - name: Install uv
        uses: astral-sh/setup-uv@v7
        with:
          enable-cache: true

      - name: Set up Python
        run: uv python install 3.12

      - name: Install pandoc
        run: sudo apt-get update && sudo apt-get install -y pandoc

      - name: Install package in development mode
        run: uv sync --all-extras

      - name: Build all artifacts (man pages + completions)
        run: make build

      - name: Create release tarball
        env:
          REF_NAME: ${{ github.ref_name }}
          INPUT_VERSION: ${{ inputs.version }}
        run: |
          # Use input version for workflow_dispatch, or extract from tag
          if [ -n "$INPUT_VERSION" ]; then
            VERSION="$INPUT_VERSION"
          else
            VERSION="${REF_NAME#v}"
          fi
          RELEASE_DIR="git-adr-${VERSION}"
          mkdir -p "${RELEASE_DIR}"

          # Structure matches git-lfs: binary instructions + man + completions + install
          cp -r share/man "${RELEASE_DIR}/" 2>/dev/null || true
          cp -r share/completions "${RELEASE_DIR}/" 2>/dev/null || true
          cp script/install.sh "${RELEASE_DIR}/"
          chmod +x "${RELEASE_DIR}/install.sh"
          cp README.md "${RELEASE_DIR}/"
          cp CHANGELOG.md "${RELEASE_DIR}/" 2>/dev/null || true
          cp LICENSE "${RELEASE_DIR}/" 2>/dev/null || true

          # Single tarball (Python package is platform-independent)
          tar -czvf "git-adr-${VERSION}.tar.gz" "${RELEASE_DIR}"

      - name: Upload release artifacts
        uses: actions/upload-artifact@v6
        with:
          name: release-artifacts
          path: |
            git-adr-*.tar.gz

  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [build, build-release-artifacts]
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Download package artifacts
        uses: actions/download-artifact@v6
        with:
          name: dist
          path: dist/

      - name: Download release artifacts
        uses: actions/download-artifact@v6
        with:
          name: release-artifacts
          path: release/

      - name: Determine version and create tag if needed
        id: version
        env:
          REF_NAME: ${{ github.ref_name }}
          INPUT_VERSION: ${{ inputs.version }}
        run: |
          if [ -n "$INPUT_VERSION" ]; then
            VERSION="$INPUT_VERSION"
            TAG="v${VERSION}"
            # Create tag if it doesn't exist
            if ! git rev-parse "$TAG" >/dev/null 2>&1; then
              git config user.name "github-actions[bot]"
              git config user.email "github-actions[bot]@users.noreply.github.com"
              git tag -a "$TAG" -m "Release $TAG"
              git push origin "$TAG"
            fi
          else
            TAG="$REF_NAME"
            VERSION="${REF_NAME#v}"
          fi
          echo "tag=${TAG}" >> "$GITHUB_OUTPUT"
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          files: |
            dist/*
            release/*
          generate_release_notes: true
          body: |
            ## Installation

            ### Homebrew (macOS)
            ```bash
            brew tap zircote/git-adr
            brew install git-adr
            ```

            ### Via pip/uv
            ```bash
            pip install git-adr
            # or
            uv tool install git-adr
            ```

            ### From release tarball (includes man pages + completions)
            ```bash
            # Download and extract (replace VERSION with actual version, e.g., 0.1.0)
            VERSION=${{ steps.version.outputs.tag }}
            curl -sL https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/git-adr-${{ steps.version.outputs.version }}.tar.gz | tar xz
            cd git-adr-*/

            # Install (installs package via pip/uv, man pages, and completions)
            ./install.sh --local  # or: sudo ./install.sh

            # Or install man pages only
            sudo ./install.sh --man-only
            ```

            ### Shell completion
            After installing, enable shell completion:
            ```bash
            git-adr completion bash --install
            git-adr completion zsh --install
            git-adr completion fish --install
            ```

            ### Usage
            ```bash
            git adr init              # Initialize in a repository
            git adr new "Title"       # Create an ADR
            git adr list              # List all ADRs
            man git-adr               # View documentation
            ```

  publish:
    name: Publish to PyPI
    runs-on: ubuntu-latest
    needs: build
    environment: pypi
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v6
        with:
          name: dist
          path: dist/

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          skip-existing: true

  update-homebrew:
    name: Update Homebrew Formula
    runs-on: ubuntu-latest
    needs: publish
    # Don't fail the release if Homebrew update fails
    continue-on-error: true
    steps:
      - name: Wait for PyPI availability
        id: wait
        env:
          REF_NAME: ${{ github.ref_name }}
          INPUT_VERSION: ${{ inputs.version }}
        run: |
          if [ -n "$INPUT_VERSION" ]; then
            VERSION="$INPUT_VERSION"
          else
            VERSION="${REF_NAME#v}"
          fi
          echo "Waiting for git-adr==${VERSION} on PyPI..."
          AVAILABLE=false
          for i in {1..30}; do
            if curl -sf "https://pypi.org/pypi/git-adr/${VERSION}/json" > /dev/null 2>&1; then
              echo "Package available on PyPI"
              AVAILABLE=true
              break
            fi
            echo "Attempt $i: Not yet available, waiting 10s..."
            sleep 10
          done
          if [ "$AVAILABLE" = "false" ]; then
            echo "::warning::Package not available on PyPI after 5 minutes"
            exit 1
          fi

      - name: Get PyPI SHA256
        id: pypi
        env:
          REF_NAME: ${{ github.ref_name }}
          INPUT_VERSION: ${{ inputs.version }}
        run: |
          if [ -n "$INPUT_VERSION" ]; then
            VERSION="$INPUT_VERSION"
          else
            VERSION="${REF_NAME#v}"
          fi
          PYPI_JSON=$(curl -sf "https://pypi.org/pypi/git-adr/${VERSION}/json")
          if [ -z "$PYPI_JSON" ]; then
            echo "::error::Failed to fetch PyPI metadata"
            exit 1
          fi
          SDIST_URL=$(echo "$PYPI_JSON" | jq -r '.urls[] | select(.packagetype=="sdist") | .url')
          SDIST_SHA256=$(echo "$PYPI_JSON" | jq -r '.urls[] | select(.packagetype=="sdist") | .digests.sha256')
          if [ -z "$SDIST_URL" ] || [ "$SDIST_URL" = "null" ]; then
            echo "::error::Could not find sdist URL in PyPI response"
            exit 1
          fi
          echo "url=${SDIST_URL}" >> "$GITHUB_OUTPUT"
          echo "sha256=${SDIST_SHA256}" >> "$GITHUB_OUTPUT"
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "Found: $SDIST_URL with SHA256: $SDIST_SHA256"

      - name: Checkout Homebrew tap
        uses: actions/checkout@v4
        with:
          repository: zircote/homebrew-git-adr
          token: ${{ secrets.HOMEBREW_TAP_TOKEN }}
          path: homebrew-tap

      - name: Generate formula
        env:
          VERSION: ${{ steps.pypi.outputs.version }}
          SHA256: ${{ steps.pypi.outputs.sha256 }}
          URL: ${{ steps.pypi.outputs.url }}
        run: |
          cd homebrew-tap

          # Function to get PyPI sdist info for a package
          get_pypi_info() {
            local pkg=$1
            local json=$(curl -sf "https://pypi.org/pypi/${pkg}/json")
            local url=$(echo "$json" | jq -r '.urls[] | select(.packagetype=="sdist") | .url' | head -1)
            local sha=$(echo "$json" | jq -r '.urls[] | select(.packagetype=="sdist") | .digests.sha256' | head -1)
            echo "${url}|${sha}"
          }

          echo "Fetching dependency info from PyPI..."

          # Core dependencies (from pyproject.toml)
          TYPER_INFO=$(get_pypi_info "typer")
          RICH_INFO=$(get_pypi_info "rich")
          FRONTMATTER_INFO=$(get_pypi_info "python-frontmatter")
          MISTUNE_INFO=$(get_pypi_info "mistune")
          PYYAML_INFO=$(get_pypi_info "pyyaml")

          # Transitive dependencies
          CLICK_INFO=$(get_pypi_info "click")
          TYPING_EXT_INFO=$(get_pypi_info "typing-extensions")
          SHELLINGHAM_INFO=$(get_pypi_info "shellingham")
          MARKDOWN_IT_INFO=$(get_pypi_info "markdown-it-py")
          MDURL_INFO=$(get_pypi_info "mdurl")
          PYGMENTS_INFO=$(get_pypi_info "pygments")

          # Generate formula with proper indentation
          {
            echo 'class GitAdr < Formula'
            echo '  include Language::Python::Virtualenv'
            echo ''
            echo '  desc "Architecture Decision Records management using git notes"'
            echo '  homepage "https://github.com/zircote/git-adr"'
            echo '  license "MIT"'
            echo "  url \"${URL}\""
            echo "  sha256 \"${SHA256}\""
            echo ''
            echo '  depends_on "libyaml"'
            echo '  depends_on "python@3.12"'
            echo ''
          } > Formula/git-adr.rb

          # Add resource blocks
          add_resource() {
            local name=$1
            local info=$2
            local url=$(echo "$info" | cut -d'|' -f1)
            local sha=$(echo "$info" | cut -d'|' -f2)
            {
              echo "  resource \"${name}\" do"
              echo "    url \"${url}\""
              echo "    sha256 \"${sha}\""
              echo "  end"
              echo ""
            } >> Formula/git-adr.rb
          }

          add_resource "click" "$CLICK_INFO"
          add_resource "markdown-it-py" "$MARKDOWN_IT_INFO"
          add_resource "mdurl" "$MDURL_INFO"
          add_resource "mistune" "$MISTUNE_INFO"
          add_resource "pygments" "$PYGMENTS_INFO"
          add_resource "python-frontmatter" "$FRONTMATTER_INFO"
          add_resource "pyyaml" "$PYYAML_INFO"
          add_resource "rich" "$RICH_INFO"
          add_resource "shellingham" "$SHELLINGHAM_INFO"
          add_resource "typer" "$TYPER_INFO"
          add_resource "typing-extensions" "$TYPING_EXT_INFO"

          {
            echo '  def install'
            echo '    virtualenv_install_with_resources'
            echo ''
            echo '    # Generate and install shell completions'
            echo '    generate_completions_from_executable(bin/"git-adr", "completion")'
            echo '  end'
            echo ''
            echo '  def caveats'
            echo '    <<~EOS'
            echo '      To use git-adr as a git subcommand, add this alias:'
            echo '        git config --global alias.adr '"'"'!git-adr'"'"''
            echo ''
            echo '      Then you can use: git adr <command>'
            echo '    EOS'
            echo '  end'
            echo ''
            echo '  test do'
            echo '    system bin/"git-adr", "--version"'
            echo '  end'
            echo 'end'
          } >> Formula/git-adr.rb

          echo "Generated formula:"
          cat Formula/git-adr.rb

      - name: Commit and push
        env:
          VERSION: ${{ steps.pypi.outputs.version }}
          HOMEBREW_TAP_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
        run: |
          cd homebrew-tap
          # Check if there are changes to commit
          if git diff --quiet Formula/git-adr.rb; then
            echo "No changes to formula - already up to date"
            exit 0
          fi
          # Explicitly set remote URL with token for cross-repo push
          git remote set-url origin "https://x-access-token:${HOMEBREW_TAP_TOKEN}@github.com/zircote/homebrew-git-adr.git"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add Formula/git-adr.rb
          git commit -m "git-adr ${VERSION}"
          git push
