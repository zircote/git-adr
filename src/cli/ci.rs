//! CI/CD workflow generation for ADR integration.

use anyhow::Result;
use clap::{Args as ClapArgs, Subcommand};
use colored::Colorize;
use std::fs;
use std::path::Path;

use crate::core::Git;

/// Arguments for the CI command.
#[derive(ClapArgs, Debug)]
pub struct Args {
    /// CI subcommand.
    #[command(subcommand)]
    pub command: CiCommand,
}

/// CI subcommands.
#[derive(Subcommand, Debug)]
pub enum CiCommand {
    /// Generate GitHub Actions workflow.
    Github(GithubArgs),

    /// Generate GitLab CI configuration.
    Gitlab(GitlabArgs),
}

/// Arguments for GitHub Actions generation.
#[derive(ClapArgs, Debug)]
pub struct GithubArgs {
    /// Output directory.
    #[arg(long, short, default_value = ".github/workflows")]
    pub output: String,

    /// Force overwrite existing files.
    #[arg(long, short)]
    pub force: bool,

    /// Include ADR validation in PR checks.
    #[arg(long, default_value = "true")]
    pub validation: bool,

    /// Include ADR sync on push.
    #[arg(long, default_value = "true")]
    pub sync: bool,
}

/// Arguments for GitLab CI generation.
#[derive(ClapArgs, Debug)]
pub struct GitlabArgs {
    /// Output file path.
    #[arg(long, short, default_value = ".gitlab-ci.yml")]
    pub output: String,

    /// Force overwrite existing file.
    #[arg(long, short)]
    pub force: bool,

    /// Include ADR validation in pipeline.
    #[arg(long, default_value = "true")]
    pub validation: bool,

    /// Include ADR sync in pipeline.
    #[arg(long, default_value = "true")]
    pub sync: bool,
}

/// Run the CI command.
///
/// # Errors
///
/// Returns an error if CI generation fails.
pub fn run(args: Args) -> Result<()> {
    let git = Git::new();
    git.check_repository()?;

    match args.command {
        CiCommand::Github(github_args) => run_github(github_args),
        CiCommand::Gitlab(gitlab_args) => run_gitlab(gitlab_args),
    }
}

/// Generate GitHub Actions workflow.
fn run_github(args: GithubArgs) -> Result<()> {
    let output_dir = Path::new(&args.output);

    if !output_dir.exists() {
        fs::create_dir_all(output_dir)?;
        eprintln!("{} Created {}", "✓".green(), args.output.cyan());
    }

    let workflow_path = output_dir.join("adr.yml");

    if workflow_path.exists() && !args.force {
        anyhow::bail!(
            "Workflow file already exists: {}. Use --force to overwrite.",
            workflow_path.display()
        );
    }

    let workflow = generate_github_workflow(args.validation, args.sync);
    fs::write(&workflow_path, workflow)?;

    eprintln!(
        "{} Generated GitHub Actions workflow: {}",
        "✓".green(),
        workflow_path.display().to_string().cyan()
    );

    eprintln!();
    eprintln!("{} Workflow includes:", "→".blue());
    if args.validation {
        eprintln!("  • ADR validation on pull requests");
    }
    if args.sync {
        eprintln!("  • ADR sync on push to main branch");
    }

    Ok(())
}

/// Generate GitLab CI configuration.
fn run_gitlab(args: GitlabArgs) -> Result<()> {
    let output_path = Path::new(&args.output);

    if output_path.exists() && !args.force {
        anyhow::bail!(
            "GitLab CI file already exists: {}. Use --force to overwrite.",
            output_path.display()
        );
    }

    let config = generate_gitlab_ci(args.validation, args.sync);
    fs::write(output_path, config)?;

    eprintln!(
        "{} Generated GitLab CI configuration: {}",
        "✓".green(),
        output_path.display().to_string().cyan()
    );

    eprintln!();
    eprintln!("{} Configuration includes:", "→".blue());
    if args.validation {
        eprintln!("  • ADR validation job");
    }
    if args.sync {
        eprintln!("  • ADR sync job");
    }

    Ok(())
}

/// Generate GitHub Actions workflow content.
fn generate_github_workflow(validation: bool, sync: bool) -> String {
    let mut workflow = String::new();

    workflow.push_str(
        r#"# ADR (Architecture Decision Records) CI/CD Workflow
# Generated by git-adr

name: ADR

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

env:
  GIT_ADR_VERSION: "1.0.0"

jobs:
"#,
    );

    if validation {
        workflow.push_str(
            r#"
  validate:
    name: Validate ADRs
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install git-adr
        run: |
          curl -sSL https://github.com/zircote/git-adr/releases/download/v${{ env.GIT_ADR_VERSION }}/git-adr-x86_64-unknown-linux-gnu.tar.gz | tar xz
          sudo mv git-adr /usr/local/bin/

      - name: Fetch ADR notes
        run: |
          git fetch origin 'refs/notes/*:refs/notes/*' || true

      - name: List ADRs
        run: git-adr list

      - name: Validate ADR references
        run: |
          # Check for ADR references in commit messages
          COMMITS=$(git log --format="%s" origin/${{ github.base_ref }}..HEAD)
          echo "Checking commits for ADR references..."
          echo "$COMMITS" | grep -i "ADR-" && echo "✓ Found ADR references" || echo "→ No ADR references found"
"#,
        );
    }

    if sync {
        workflow.push_str(
            r#"
  sync:
    name: Sync ADRs
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install git-adr
        run: |
          curl -sSL https://github.com/zircote/git-adr/releases/download/v${{ env.GIT_ADR_VERSION }}/git-adr-x86_64-unknown-linux-gnu.tar.gz | tar xz
          sudo mv git-adr /usr/local/bin/

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Fetch ADR notes
        run: |
          git fetch origin 'refs/notes/*:refs/notes/*' || true

      - name: Sync ADRs
        run: |
          git-adr sync || echo "→ No changes to sync"
"#,
        );
    }

    workflow
}

/// Generate GitLab CI content.
fn generate_gitlab_ci(validation: bool, sync: bool) -> String {
    let mut config = String::new();

    config.push_str(
        r#"# ADR (Architecture Decision Records) CI/CD Configuration
# Generated by git-adr

stages:
  - validate
  - sync

variables:
  GIT_ADR_VERSION: "1.0.0"

.install-git-adr: &install-git-adr
  - curl -sSL https://github.com/zircote/git-adr/releases/download/v${GIT_ADR_VERSION}/git-adr-x86_64-unknown-linux-gnu.tar.gz | tar xz
  - mv git-adr /usr/local/bin/
  - git fetch origin 'refs/notes/*:refs/notes/*' || true
"#,
    );

    if validation {
        config.push_str(
            r#"

validate-adrs:
  stage: validate
  image: ubuntu:latest
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  before_script:
    - apt-get update && apt-get install -y curl git
    - *install-git-adr
  script:
    - git-adr list
    - |
      echo "Checking for ADR references in commits..."
      git log --format="%s" ${CI_MERGE_REQUEST_DIFF_BASE_SHA}..HEAD | grep -i "ADR-" && echo "✓ Found ADR references" || echo "→ No ADR references found"
"#,
        );
    }

    if sync {
        config.push_str(
            r#"

sync-adrs:
  stage: sync
  image: ubuntu:latest
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  before_script:
    - apt-get update && apt-get install -y curl git
    - git config user.name "GitLab CI"
    - git config user.email "ci@gitlab.com"
    - *install-git-adr
  script:
    - git-adr sync || echo "→ No changes to sync"
"#,
        );
    }

    config
}
